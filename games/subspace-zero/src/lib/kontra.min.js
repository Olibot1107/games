var kontra=(function(){let callbacks={};function on(event,callback){callbacks[event]=callbacks[event]||[];callbacks[event].push(callback)}
  function emit(event,...args){(callbacks[event]||[]).map(fn=>fn(...args))}
  let canvasEl,context;function getCanvas(){return canvasEl}
  function getContext(){return context}
  function init(canvas){canvasEl=document.getElementById(canvas)||canvas||document.querySelector('canvas');if(!canvasEl){throw Error('You must provide a canvas element for the game')}
    context=canvasEl.getContext('2d');context.imageSmoothingEnabled=!1;emit('init');return{canvas:canvasEl,context}}
  let imageAssets={};function setImagePath(path){}
  function rotatePoint(point,angle){let sin=Math.sin(angle);let cos=Math.cos(angle);let x=point.x*cos-point.y*sin;let y=point.x*sin+point.y*cos;return{x,y}}
  function clamp(min,max,value){return Math.min(Math.max(min,value),max)}
  function collides(obj1,obj2){if(obj1.rotation||obj2.rotation)return null;[obj1,obj2]=[obj1,obj2].map(obj=>getWorldRect(obj));return obj1.x<obj2.x+obj2.width&&obj1.x+obj1.width>obj2.x&&obj1.y<obj2.y+obj2.height&&obj1.y+obj1.height>obj2.y}
  function getWorldRect(obj){let{x=0,y=0,width,height}=obj.world||obj;if(obj.mapwidth){width=obj.mapwidth;height=obj.mapheight}
    if(obj.anchor){x-=width*obj.anchor.x;y-=height*obj.anchor.y}
    if(width<0){x+=width;width*=-1}
    if(height<0){y+=height;height*=-1}
    return{x,y,width,height}}
  class Vector{constructor(x=0,y=0,vec={}){this.x=x;this.y=y;if(vec._c){this.clamp(vec._a,vec._b,vec._d,vec._e);this.x=x;this.y=y}}
    add(vec){return new Vector(this.x+vec.x,this.y+vec.y,this)}
    subtract(vec){return new Vector(this.x-vec.x,this.y-vec.y,this)}
    scale(value){return new Vector(this.x*value,this.y*value)}
    normalize(length=this.length()){return new Vector(this.x/length,this.y/length)}
    dot(vec){return this.x*vec.x+this.y*vec.y}
    length(){return Math.hypot(this.x,this.y)}
    distance(vec){return Math.hypot(this.x-vec.x,this.y-vec.y)}
    angle(vec){return Math.acos(this.dot(vec)/(this.length()*vec.length()))}
    clamp(xMin,yMin,xMax,yMax){this._c=!0;this._a=xMin;this._b=yMin;this._d=xMax;this._e=yMax}
    get x(){return this._x}
    get y(){return this._y}
    set x(value){this._x=(this._c?clamp(this._a,this._d,value):value)}
    set y(value){this._y=(this._c?clamp(this._b,this._e,value):value)}}
  function factory$1(){return new Vector(...arguments)}
  factory$1.prototype=Vector.prototype;factory$1.class=Vector;class Updatable{constructor(properties){return this.init(properties)}
    init(properties={}){this.position=factory$1();this.velocity=factory$1();this.acceleration=factory$1();this.ttl=Infinity;Object.assign(this,properties)}
    update(dt){this.advance(dt)}
    advance(dt){let acceleration=this.acceleration;if(dt){acceleration=acceleration.scale(dt)}
      this.velocity=this.velocity.add(acceleration);let velocity=this.velocity;if(dt){velocity=velocity.scale(dt)}
      this.position=this.position.add(velocity);this._pc();this.ttl--}
    get dx(){return this.velocity.x}
    get dy(){return this.velocity.y}
    set dx(value){this.velocity.x=value}
    set dy(value){this.velocity.y=value}
    get ddx(){return this.acceleration.x}
    get ddy(){return this.acceleration.y}
    set ddx(value){this.acceleration.x=value}
    set ddy(value){this.acceleration.y=value}
    isAlive(){return this.ttl>0}
    _pc(){}}
  let noop=()=>{};let srOnlyStyle='position:absolute;width:1px;height:1px;overflow:hidden;';function addToDom(node,canvas){let container=canvas.parentNode;node.setAttribute('data-kontra','');if(container){let target=container.querySelector('[data-kontra]:last-of-type')||canvas;container.insertBefore(node,target.nextSibling)}else{document.body.appendChild(node)}}
  class GameObject extends Updatable{init({width=0,height=0,context=getContext(),render=this.draw,update=this.advance,children=[],anchor={x:0,y:0},sx=0,sy=0,opacity=1,rotation=0,scaleX=1,scaleY=1,...props}={}){this.children=[];super.init({width,height,context,anchor,sx,sy,opacity,rotation,scaleX,scaleY,...props});this._di=!0;this._uw();children.map(child=>this.addChild(child));this._rf=render;this._uf=update}
    update(dt){this._uf(dt);this.children.map(child=>child.update&&child.update(dt))}
    render(filterObjects){let context=this.context;context.save();if(this.x||this.y){context.translate(this.x,this.y)}
      if(this.rotation){context.rotate(this.rotation)}
      if(this.sx||this.sy){context.translate(-this.sx,-this.sy)}
      if(this.scaleX!=1||this.scaleY!=1){context.scale(this.scaleX,this.scaleY)}
      let anchorX=-this.width*this.anchor.x;let anchorY=-this.height*this.anchor.y;if(anchorX||anchorY){context.translate(anchorX,anchorY)}
      this.context.globalAlpha=this.opacity;this._rf();if(anchorX||anchorY){context.translate(-anchorX,-anchorY)}
      let children=this.children;if(filterObjects){children=children.filter(filterObjects)}
      children.map(child=>child.render&&child.render());context.restore()}
    draw(){}
    _pc(prop,value){this._uw();this.children.map(child=>child._pc())}
    get x(){return this.position.x}
    get y(){return this.position.y}
    set x(value){this.position.x=value;this._pc()}
    set y(value){this.position.y=value;this._pc()}
    get width(){return this._w}
    set width(value){this._w=value;this._pc()}
    get height(){return this._h}
    set height(value){this._h=value;this._pc()}
    _uw(){if(!this._di)return;let{_wx=0,_wy=0,_wo=1,_wr=0,_wsx=1,_wsy=1}=(this.parent||{});this._wx=this.x;this._wy=this.y;this._ww=this.width;this._wh=this.height;this._wo=_wo*this.opacity;this._wr=_wr+this.rotation;let{x,y}=rotatePoint({x:this.x,y:this.y},_wr);this._wx=x;this._wy=y;this._wsx=_wsx*this.scaleX;this._wsy=_wsy*this.scaleY;this._wx=this.x*_wsx;this._wy=this.y*_wsy;this._ww=this.width*this._wsx;this._wh=this.height*this._wsy;this._wx+=_wx;this._wy+=_wy}
    get world(){return{x:this._wx,y:this._wy,width:this._ww,height:this._wh,opacity:this._wo,rotation:this._wr,scaleX:this._wsx,scaleY:this._wsy}}
    addChild(child,{absolute=!1}={}){this.children.push(child);child.parent=this;child._pc=child._pc||noop;child._pc()}
    removeChild(child){let index=this.children.indexOf(child);if(index!==-1){this.children.splice(index,1);child.parent=null;child._pc()}}
    get opacity(){return this._opa}
    set opacity(value){this._opa=value;this._pc()}
    get rotation(){return this._rot}
    set rotation(value){this._rot=value;this._pc()}
    setScale(x,y=x){this.scaleX=x;this.scaleY=y}
    get scaleX(){return this._scx}
    set scaleX(value){this._scx=value;this._pc()}
    get scaleY(){return this._scy}
    set scaleY(value){this._scy=value;this._pc()}}
  function factory$2(){return new GameObject(...arguments)}
  factory$2.prototype=GameObject.prototype;factory$2.class=GameObject;class Sprite extends factory$2.class{init({image,width=image?image.width:undefined,height=image?image.height:undefined,...props}={}){super.init({image,width,height,...props})}
    get animations(){return this._a}
    set animations(value){let prop,firstAnimation;this._a={};for(prop in value){this._a[prop]=value[prop].clone();firstAnimation=firstAnimation||this._a[prop]}
      this.currentAnimation=firstAnimation;this.width=this.width||firstAnimation.width;this.height=this.height||firstAnimation.height}
    playAnimation(name){this.currentAnimation=this.animations[name];if(!this.currentAnimation.loop){this.currentAnimation.reset()}}
    advance(dt){super.advance(dt);if(this.currentAnimation){this.currentAnimation.update(dt)}}
    draw(){if(this.image){this.context.drawImage(this.image,0,0,this.image.width,this.image.height)}
      if(this.currentAnimation){this.currentAnimation.render({x:0,y:0,width:this.width,height:this.height,context:this.context})}
      if(this.color){this.context.fillStyle=this.color;this.context.fillRect(0,0,this.width,this.height)}}}
  function factory$3(){return new Sprite(...arguments)}
  factory$3.prototype=Sprite.prototype;factory$3.class=Sprite;let fontSizeRegex=/(\d+)(\w+)/;function parseFont(font){let match=font.match(fontSizeRegex);let size=+match[1];let unit=match[2];let computed=size;return{size,unit,computed}}
  class Text extends factory$2.class{init({text='',textAlign='',lineHeight=1,font=getContext().font,...props}={}){text=''+text;super.init({text,textAlign,lineHeight,font,...props});this._p()}
    get width(){return this._w}
    set width(value){this._d=!0;this._w=value;this._fw=value}
    get text(){return this._t}
    set text(value){this._d=!0;this._t=value}
    get font(){return this._f}
    set font(value){this._d=!0;this._f=value;this._fs=parseFont(value).computed}
    get lineHeight(){return this._lh}
    set lineHeight(value){this._d=!0;this._lh=value}
    render(){if(this._d){this._p()}
      super.render()}
    _p(){this._s=[];this._d=!1;let context=this.context;context.font=this.font;if(!this._s.length&&this._fw){let parts=this.text.split(' ');let start=0;let i=2;for(;i<=parts.length;i++){let str=parts.slice(start,i).join(' ');let width=context.measureText(str).width;if(width>this._fw){this._s.push(parts.slice(start,i-1).join(' '));start=i-1}}
      this._s.push(parts.slice(start,i).join(' '))}
      if(!this._s.length&&this.text.includes('\n')){let width=0;this.text.split('\n').map(str=>{this._s.push(str);width=Math.max(width,context.measureText(str).width)});this._w=this._fw||width}
      if(!this._s.length){this._s.push(this.text);this._w=this._fw||context.measureText(this.text).width}
      this.height=this._fs+((this._s.length-1)*this._fs*this.lineHeight);this._uw()}
    draw(){let alignX=0;let textAlign=this.textAlign;let context=this.context;textAlign=this.textAlign||(context.canvas.dir==='rtl'?'right':'left');alignX=textAlign==='right'?this.width:textAlign==='center'?this.width/2|0:0;this._s.map((str,index)=>{context.textBaseline='top';context.textAlign=textAlign;context.fillStyle=this.color;context.font=this.font;context.fillText(str,alignX,this._fs*this.lineHeight*index)})}}
  function factory$4(){return new Text(...arguments)}
  factory$4.prototype=Text.prototype;factory$4.class=Text;let pointers=new WeakMap();let callbacks$1={};let pressedButtons={};let buttonMap={0:'left',1:'middle',2:'right'};function getPointer(canvas=getCanvas()){return pointers.get(canvas)}
  function circleRectCollision(object,pointer){let{x,y,width,height}=getWorldRect(object);do{x-=object.sx||0;y-=object.sy||0}while((object=object.parent));let dx=pointer.x-Math.max(x,Math.min(pointer.x,x+width));let dy=pointer.y-Math.max(y,Math.min(pointer.y,y+height));return(dx*dx+dy*dy)<(pointer.radius*pointer.radius)}
  function getCurrentObject(pointer){let renderedObjects=pointer._lf.length?pointer._lf:pointer._cf;for(let i=renderedObjects.length-1;i>=0;i--){let object=renderedObjects[i];let collides=object.collidesWithPointer?object.collidesWithPointer(pointer):circleRectCollision(object,pointer);if(collides){return object}}}
  function getPropValue(style,value){return parseFloat(style.getPropertyValue(value))||0}
  function getCanvasOffset(pointer){let{canvas,_s}=pointer;let rect=canvas.getBoundingClientRect();let transform=_s.transform!=='none'?_s.transform.replace('matrix(','').split(','):[1,1,1,1];let transformScaleX=parseFloat(transform[0]);let transformScaleY=parseFloat(transform[3]);let borderWidth=(getPropValue(_s,'border-left-width')+getPropValue(_s,'border-right-width'))*transformScaleX;let borderHeight=(getPropValue(_s,'border-top-width')+getPropValue(_s,'border-bottom-width'))*transformScaleY;let paddingWidth=(getPropValue(_s,'padding-left')+getPropValue(_s,'padding-right'))*transformScaleX;let paddingHeight=(getPropValue(_s,'padding-top')+getPropValue(_s,'padding-bottom'))*transformScaleY;return{scaleX:(rect.width-borderWidth-paddingWidth)/canvas.width,scaleY:(rect.height-borderHeight-paddingHeight)/canvas.height,offsetX:rect.left+(getPropValue(_s,'border-left-width')+getPropValue(_s,'padding-left'))*transformScaleX,offsetY:rect.top+(getPropValue(_s,'border-top-width')+getPropValue(_s,'padding-top'))*transformScaleY}}
  function pointerDownHandler(evt){let button=evt.button!==undefined?buttonMap[evt.button]:'left';pressedButtons[button]=!0;pointerHandler(evt,'onDown')}
  function pointerUpHandler(evt){let button=evt.button!==undefined?buttonMap[evt.button]:'left';pressedButtons[button]=!1;pointerHandler(evt,'onUp')}
  function mouseMoveHandler(evt){pointerHandler(evt,'onOver')}
  function blurEventHandler(evt){let pointer=pointers.get(evt.target);pointer._oo=null;pressedButtons={}}
  function pointerHandler(evt,eventName){evt.preventDefault();let canvas=evt.target;let pointer=pointers.get(canvas);let{scaleX,scaleY,offsetX,offsetY}=getCanvasOffset(pointer);let isTouchEvent=['touchstart','touchmove','touchend'].indexOf(evt.type)!==-1;if(isTouchEvent){pointer.touches={};for(var i=0;i<evt.touches.length;i++){pointer.touches[evt.touches[i].identifier]={id:evt.touches[i].identifier,x:(evt.touches[i].clientX-offsetX)/scaleX,y:(evt.touches[i].clientY-offsetY)/scaleY,changed:!1}}
    for(var i=evt.changedTouches.length;i--;){const id=evt.changedTouches[i].identifier;if(typeof pointer.touches[id]!=="undefined"){pointer.touches[id].changed=!0}
      let clientX=evt.changedTouches[i].clientX;let clientY=evt.changedTouches[i].clientY;pointer.x=(clientX-offsetX)/scaleX;pointer.y=(clientY-offsetY)/scaleY;let object=getCurrentObject(pointer);if(object&&object[eventName]){object[eventName](evt)}
      if(callbacks$1[eventName]){callbacks$1[eventName](evt,object)}}}else{pointer.x=(evt.clientX-offsetX)/scaleX;pointer.y=(evt.clientY-offsetY)/scaleY;let object=getCurrentObject(pointer);if(object&&object[eventName]){object[eventName](evt)}
    if(callbacks$1[eventName]){callbacks$1[eventName](evt,object)}
    if(eventName=='onOver'){if(object!=pointer._oo&&pointer._oo&&pointer._oo.onOut){pointer._oo.onOut(evt)}
      pointer._oo=object}}}
  function initPointer({radius=5,canvas=getCanvas()}={}){let pointer=pointers.get(canvas);if(!pointer){let style=window.getComputedStyle(canvas);pointer={x:0,y:0,radius,touches:{},canvas,_cf:[],_lf:[],_o:[],_oo:null,_s:style};pointers.set(canvas,pointer)}
    canvas.addEventListener('mousedown',pointerDownHandler);canvas.addEventListener('touchstart',pointerDownHandler);canvas.addEventListener('mouseup',pointerUpHandler);canvas.addEventListener('touchend',pointerUpHandler);canvas.addEventListener('touchcancel',pointerUpHandler);canvas.addEventListener('blur',blurEventHandler);canvas.addEventListener('mousemove',mouseMoveHandler);canvas.addEventListener('touchmove',mouseMoveHandler);if(!pointer._t){pointer._t=!0;on('tick',()=>{pointer._lf.length=0;pointer._cf.map(object=>{pointer._lf.push(object)});pointer._cf.length=0})}
    return pointer}
  function track(...objects){objects.map(object=>{let canvas=object.context?object.context.canvas:getCanvas();let pointer=pointers.get(canvas);if(!pointer){throw new ReferenceError('Pointer events not initialized for the objects canvas')}
    if(!object._r){object._r=object.render;object.render=function(){pointer._cf.push(this);this._r()};pointer._o.push(object)}})}
  function untrack(...objects){objects.map(object=>{let canvas=object.context?object.context.canvas:getCanvas();let pointer=pointers.get(canvas);if(!pointer){throw new ReferenceError('Pointer events not initialized for the objects canvas')}
    object.render=object._r;object._r=0;let index=pointer._o.indexOf(object);if(index!==-1){pointer._o.splice(index,1)}})}
  function pointerOver(object){let canvas=object.context?object.context.canvas:getCanvas();let pointer=pointers.get(canvas);if(!pointer){throw new ReferenceError('Pointer events not initialized for the objects canvas')}
    return pointer._o.includes(object)&&getCurrentObject(pointer)===object}
  function onPointerDown(callback){callbacks$1.onDown=callback}
  function onPointerUp(callback){callbacks$1.onUp=callback}
  function pointerPressed(button){return!!pressedButtons[button]}
  class Button extends factory$3.class{init({padX=0,padY=0,text,onDown,onUp,...props}={}){super.init({padX,padY,...props});this.textNode=factory$4({...text,context:this.context});if(!this.width){this.width=this.textNode.width;this.height=this.textNode.height}
    track(this);this.addChild(this.textNode);this._od=onDown||noop;this._ou=onUp||noop;const button=this._dn=document.createElement('button');button.style=srOnlyStyle;button.textContent=this.text;button.addEventListener('focus',()=>this.focus());button.addEventListener('blur',()=>this.blur());button.addEventListener('keydown',(evt)=>this._kd(evt));button.addEventListener('keyup',(evt)=>this._ku(evt));addToDom(button,this.context.canvas);this._uw();this._p()}
    get text(){return this.textNode.text}
    set text(value){this._d=!0;this.textNode.text=value}
    destroy(){this._dn.remove()}
    _p(){if(this.text!==this._dn.textContent){this._dn.textContent=this.text}
      this.textNode._p();let width=this.textNode.width+this.padX*2;let height=this.textNode.height+this.padY*2;this.width=Math.max(width,this.width);this.height=Math.max(height,this.height);this._uw()}
    render(){if(this._d){this._p()}
      super.render()}
    enable(){this.disabled=this._dn.disabled=!1;this.onEnable()}
    disable(){this.disabled=this._dn.disabled=!0;this.onDisable()}
    focus(){if(!this.disabled){this.focused=!0;if(document.activeElement!=this._dn)this._dn.focus();this.onFocus()}}
    blur(){this.focused=!1;if(document.activeElement==this._dn)this._dn.blur();this.onBlur()}
    onOver(){if(!this.disabled){this.hovered=!0}}
    onOut(){this.hovered=!1}
    onEnable(){}
    onDisable(){}
    onFocus(){}
    onBlur(){}
    onDown(){if(!this.disabled){this.pressed=!0;this._od()}}
    onUp(){if(!this.disabled){this.pressed=!1;this._ou()}}
    _kd(evt){if(evt.code=='Enter'||evt.code=='Space'){this.onDown()}}
    _ku(evt){if(evt.code=='Enter'||evt.code=='Space'){this.onUp()}}}
  function factory$5(){return new Button(...arguments)}
  factory$5.prototype=Button.prototype;factory$5.class=Button;function clear(context){let canvas=context.canvas;context.clearRect(0,0,canvas.width,canvas.height)}
  function GameLoop({fps=60,clearCanvas=!0,update=noop,render,context=getContext(),blur=!1}={}){if(!render){throw Error('You must provide a render() function')}
    let accumulator=0;let delta=1E3/fps;let step=1/fps;let clearFn=clearCanvas?clear:noop;let last,rAF,now,dt,loop;let focused=!0;if(!blur){window.addEventListener('focus',()=>{focused=!0});window.addEventListener('blur',()=>{focused=!1})}
    function frame(){rAF=requestAnimationFrame(frame);if(!focused)return;now=performance.now();dt=now-last;last=now;if(dt>1E3){return}
      emit('tick');accumulator+=dt;while(accumulator>=delta){loop.update(step);accumulator-=delta}
      clearFn(context);loop.render()}
    loop={update,render,isStopped:!0,start(){last=performance.now();this.isStopped=!1;requestAnimationFrame(frame)},stop(){this.isStopped=!0;cancelAnimationFrame(rAF)},_frame:frame,set _last(value){last=value}};return loop}
  let keydownCallbacks={};let keyupCallbacks={};let pressedKeys={};let keyMap={'Enter':'enter','Escape':'esc','Space':'space','ArrowLeft':'left','ArrowUp':'up','ArrowRight':'right','ArrowDown':'down'};function call(callback=noop,evt){if(callback._pd){evt.preventDefault()}
    callback(evt)}
  function keydownEventHandler(evt){let key=keyMap[evt.code];let callback=keydownCallbacks[key];pressedKeys[key]=!0;call(callback,evt)}
  function keyupEventHandler(evt){let key=keyMap[evt.code];let callback=keyupCallbacks[key];pressedKeys[key]=!1;call(callback,evt)}
  function blurEventHandler$1(){pressedKeys={}}
  function initKeys(){let i;for(i=0;i<26;i++){keyMap[i+65]=keyMap['Key'+String.fromCharCode(i+65)]=String.fromCharCode(i+97)}
    for(i=0;i<10;i++){keyMap[48+i]=keyMap['Digit'+i]=''+i}
    window.addEventListener('keydown',keydownEventHandler);window.addEventListener('keyup',keyupEventHandler);window.addEventListener('blur',blurEventHandler$1)}
  function bindKeys(keys,callback,{handler='keydown',preventDefault=!0}={}){const callbacks=handler=='keydown'?keydownCallbacks:keyupCallbacks;callback._pd=preventDefault;[].concat(keys).map(key=>callbacks[key]=callback)}
  function unbindKeys(keys,{handler='keydown'}={}){const callbacks=handler=='keydown'?keydownCallbacks:keyupCallbacks;[].concat(keys).map(key=>callbacks[key]=0)}
  function keyPressed(key){return!!pressedKeys[key]}
  function getAllNodes(object){let nodes=[];if(object._dn){nodes.push(object._dn)}else if(object.children){object.children.map(child=>{nodes=nodes.concat(getAllNodes(child))})}
    return nodes}
  class Scene extends factory$2.class{init({id,name=id,cullObjects=!0,cullFunction=collides,...props}){const section=this._dn=document.createElement('section');section.tabIndex=-1;section.style=srOnlyStyle;section.id=id;section.setAttribute('aria-label',name);super.init({id,name,cullObjects,cullFunction,...props});addToDom(section,this.context.canvas);let canvas=this.context.canvas;this.camera=factory$2({x:canvas.width/2,y:canvas.height/2,width:canvas.width,height:canvas.height,anchor:{x:0.5,y:0.5}});this.camera._pc=()=>{super._pc.call(this.camera);this.context.canvas;this.camera._wx=this.camera.x*this.scaleX;this.camera._wy=this.camera.y*this.scaleY}}
    show(){this.hidden=this._dn.hidden=!1;let focusableChild=this.children.find(child=>child.focus);if(focusableChild){focusableChild.focus()}else{this._dn.focus()}
      this.onShow()}
    hide(){this.hidden=this._dn.hidden=!0;this.onHide()}
    addChild(object,options){super.addChild(object,options);getAllNodes(object).map(node=>{this._dn.appendChild(node)})}
    removeChild(object){super.removeChild(object);getAllNodes(object).map(node=>{addToDom(node,this.context.canvas)})}
    destroy(){this._dn.remove();this.children.map(child=>child.destroy&&child.destroy())}
    update(dt){if(!this.hidden){super.update(dt)}}
    lookAt(object){object=object.world||object;let x=object.x;let y=object.y;if(object.scaleX){x/=object.scaleX;y/=object.scaleY}
      this.camera.x=x;this.camera.y=y;this._pc()}
    _pc(){super._pc();this.camera&&this.camera._pc()}
    render(){let{x,y,width,height}=this.camera;this.sx=x*this.scaleX-width/2;this.sy=y*this.scaleY-height/2;if(!this.hidden){super.render(child=>this.cullObjects?this.cullFunction(child,this.camera):!0)}}
    onShow(){}
    onHide(){}}
  function factory$9(){return new Scene(...arguments)}
  let kontra={imageAssets,setImagePath,Button:factory$5,init,getCanvas,getContext,GameLoop,GameObject:factory$2,keyMap,initKeys,bindKeys,unbindKeys,keyPressed,initPointer,getPointer,track,untrack,pointerOver,onPointerDown,onPointerUp,pointerPressed,Scene:factory$9,Sprite:factory$3,Text:factory$4,};return kontra}())